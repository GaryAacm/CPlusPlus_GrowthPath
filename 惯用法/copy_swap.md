# 复制和交换（Copy-and-Swap）惯用法详解

复制和交换（Copy-and-Swap）是C++中实现赋值运算符的一种优雅且安全的方法，特别适用于资源管理类（如智能指针、容器等）。它解决了传统赋值运算符实现中的多个问题。

## 为什么需要复制和交换？

### 传统赋值运算符的问题

1. **自赋值问题**：需要检查 `this != &rhs`，否则可能导致资源被提前释放
2. **异常安全问题**：如果在分配新资源时抛出异常，对象可能处于无效状态
3. **代码重复**：赋值运算符通常需要重复拷贝构造函数和析构函数的逻辑

### 复制和交换的优势

1. **自动处理自赋值**：通过创建副本自然避免了自赋值问题
2. **强异常保证**：要么操作完全成功，要么对象状态保持不变
3. **代码复用**：重用拷贝构造函数和交换函数的逻辑
4. **简洁性**：通常只需几行代码即可实现

## 复制和交换的工作原理

基本模式：
```cpp
ClassName& operator=(ClassName rhs) { // 注意：按值传递
    swap(*this, rhs); // 或 rhs.swap(*this)
    return *this;
}
```

工作流程：
1. 通过拷贝构造函数（对于左值）或移动构造函数（对于右值）创建临时副本
2. 交换当前对象和副本的内容
3. 副本离开作用域时自动销毁，带走旧资源

## 具体实现分析

### 方法1：传统方法（不推荐）
```cpp
smart_ptr& operator=(const smart_ptr& rhs) {
    if (*this != rhs) {
        delete ptr_;
        ptr_ = new T(rhs.ptr_); // 不安全：new可能抛出异常
    }
    return *this;
}
```
**问题**：如果 `new` 抛出异常，`ptr_` 已经释放，对象处于无效状态。

### 方法2：改进传统方法
```cpp
smart_ptr& operator=(const smart_ptr& rhs) {
    T* origin = ptr_;
    ptr_ = new T(rhs.ptr_); // 先分配，成功后释放旧资源
    delete origin;
    return *this;
}
```
**改进**：异常安全，但代码冗余且不够优雅。

### 方法3：复制和交换（显式创建副本）
```cpp
smart_ptr& operator=(const smart_ptr& rhs) {
    smart_ptr tmp(rhs); // 创建副本
    swap(tmp);         // 交换内容
    return *this;      // tmp离开作用域销毁旧资源
}
```

### 方法4：复制和交换（传值方式）
```cpp
smart_ptr& operator=(smart_ptr rhs) { // 按值传递自动创建副本
    swap(rhs);
    return *this;
}
```
**优点**：更简洁，自动处理左值和右值。

## 移动语义的整合

在C++11中，复制和交换可以统一处理拷贝赋值和移动赋值：

```cpp
smart_ptr& operator=(smart_ptr rhs) noexcept {
    swap(rhs);
    return *this;
}
```

这个单一赋值运算符可以处理：
- 左值参数：调用拷贝构造函数创建副本
- 右值参数：调用移动构造函数创建副本

## 为什么不需要单独的移动赋值运算符

当使用传值方式实现赋值运算符时：
- 对于 `s3 = s1`（左值）：调用拷贝构造函数创建副本
- 对于 `s4 = std::move(s1)`（右值）：调用移动构造函数创建副本

因此不需要单独实现移动赋值运算符，否则会导致重载歧义。

## 完整示例的关键组件

1. **拷贝构造函数**：创建资源的深拷贝
2. **移动构造函数**（C++11）：高效转移资源所有权
3. **交换函数**：高效交换两个对象的内容（应保证不抛异常）
4. **析构函数**：正确释放资源
5. **赋值运算符**：使用复制和交换惯用法

## 总结

复制和交换惯用法提供了：
1. **异常安全**：强异常保证
2. **代码简洁**：重用现有逻辑
3. **自赋值安全**：自动处理
4. **统一赋值**：C++11中可同时处理拷贝和移动赋值

这种模式是C++资源管理类的黄金标准，特别适合实现"Rule of Five"（C++11中的"Rule of Zero"的基础）。
